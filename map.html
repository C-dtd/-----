<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            margin: 0;
            padding: 0;
        }
        #screen {
            width: 1000px;
            height: 1000px;
            position: relative;
            perspective: 500px;
            overflow: hidden;
        }
        .block {
            position: absolute;
            width: 100px;
            height: 100px;
            transform-style: preserve-3d;
            left: calc(50% - 50px);
            top: calc(50% - 50px);
            animation: rotation 5s infinite;
        }
        .wall {
            background-color: rgba(222, 184, 135, 0.3);
            position: absolute;
            width: 100%;
            height: 100%;
            outline: 1px black solid;
        }
        @keyframes rotation {
            0% {
                transform: translateZ(-100px) rotate3d(0,0,0);
            }
            50% {
                transform: translateZ(-100px) rotate3d(0,1,0,180deg);
            }
            100% {
                transform: translateZ(-100px) rotate3d(0,0,0,360deg);
            }
        }
    </style>
</head>
<body>
    <div id="screen">
        
    </div>
    <canvas id="map" width="200" height="200"></canvas>
</body>

<script>
    const map = document.querySelector('#map');
    const mctx = map.getContext('2d');
    const screen = document.querySelector('#screen');

    class block {
        constructor(x1, y1, z1, x2, y2, z2) {
            this.x1 = x1;
            this.x2 = x2;
            this.y1 = y1;
            this.y2 = y2;
            this.z1 = z1;
            this.z2 = z2;
        }
        points() {
            return [
                [this.x1, this.y1, this.x1, this.y2],
                [this.x1, this.y2, this.x2, this.y2],
                [this.x2, this.y2, this.x2, this.y1],
                [this.x2, this.y1, this.x1, this.y1]
            ];
        }
        block;
    }
    class player {
        constructor(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
        }
    }

    blocks = [];
    // blocks.push(new block(0, 0, -100, 40, 40, 0));
    // blocks.push(new block(40, 0, -80, 80, 40, 0));
    blocks.push(new block(80, 0, -20, 120, 40, 0));
    // blocks.push(new block(120, 0, -40, 160, 40, 0));
    // blocks.push(new block(160, 0, -20, 200, 40, 0));
    // blocks.push(new block(0, 40, -100, 40, 80, 0));
    // blocks.push(new block(0, 80, -100, 40, 120, 0));
    pl = new player(100, 140, -10);
    cdir = Math.PI/2;

    setInterval(mapUpdate, 50);
    setInterval(screenUpdate, 50);

    function mapUpdate() {
        mctx.clearRect(0, 0, map.width, map.height);
        blocks.forEach(e => {
            mctx.strokeRect(e.x1, e.y1, e.x2-e.x1, e.y2-e.y1);
        });
        mctx.beginPath();
        mctx.moveTo(pl.x, pl.y);
        mctx.lineTo(pl.x +Math.cos(cdir -Math.PI/4)*200, pl.y -Math.sin(cdir -Math.PI/4)*200);
        mctx.moveTo(pl.x, pl.y);
        mctx.lineTo(pl.x +Math.cos(cdir)*100, pl.y -Math.sin(cdir)*100);
        mctx.moveTo(pl.x, pl.y);
        mctx.lineTo(pl.x +Math.cos(cdir +Math.PI/4)*200, pl.y -Math.sin(cdir +Math.PI/4)*200);
        mctx.closePath();
        mctx.stroke();
    }

    blocks.forEach((e) => {
        let block = document.createElement('div');
        block.setAttribute('class', 'block');
        block.innerHTML = 
        `<div class="wall"></div>
        <div class="wall"></div>
        <div class="wall"></div>
        <div class="wall"></div>`;
        screen.appendChild(block);
        e.block = block;
    });

    // screenUpdate()
    function screenUpdate() {
        blocks.forEach((e) => {
            const walls = e.block.querySelectorAll('.wall');
            for (let i=0; i<4; i++) {
                const wall = walls[i];
                const p = e.points()[i];
                wall.style.transform = 
                `
                rotateY(${[0, 90, 180, 270][i]}deg)
                translate3d(0, 0, 50px)
                `;
            }
        });
    }

    // document.addEventListener('keydown', (e) => {
    //     if (e.key == 'q') {
    //         cdir += 0.05;
    //     }
    //     if (e.key == 'e') {
    //         cdir -= 0.05;
    //     }
    //     if (e.key == 'w') {
    //         pl.y -= 0.5;
    //     }
    //     if (e.key == 's') {
    //         pl.y += 0.5;
    //     }
    //     if (e.key == 'a') {
    //         pl.x -= 0.5;
    //     }
    //     if (e.key == 'd') {
    //         pl.x += 0.5;
    //     }
    //     if (e.key == 'Shift') {
    //         pl.z += 0.5;
    //     }
    //     if (e.key == ' ') {
    //         pl.z -= 0.5;
    //     }
    // })
    
    function pointlen(x1, y1, x2, y2) {
        return ((x2-x1)**2 +(y2-y1)**2)**0.5;
    }
    function pointdir(x1, y1, x2, y2) {
        return Math.atan2(y1 -y2, x2 -x1);
    }
    function dirdiff(d1, d2) {
        diff = d2%(Math.PI*2) -d1%(Math.PI*2);
        return diff < -Math.PI ? diff+Math.PI*2 : diff;
    }
</script>
</html>